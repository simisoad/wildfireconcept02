#include "rasterizer.h"
#include <godot_cpp/core/class_db.hpp>
#include <godot_cpp/variant/utility_functions.hpp>
#include <godot_cpp/classes/geometry2d.hpp> // Wichtig für is_polygon_clockwise

using namespace godot;

// --- Bind Methods: Macht die Funktionen in GDScript verfügbar ---
void RasterizerUtils::_bind_methods() {
    ClassDB::bind_static_method("RasterizerUtils", D_METHOD("rasterize_tile_data", "mvt_tile", "config"), &RasterizerUtils::rasterize_tile_data);
    ClassDB::bind_static_method("RasterizerUtils", D_METHOD("is_point_in_polygon_cpp", "point", "polygon"), &RasterizerUtils::is_point_in_polygon);
}

RasterizerUtils::RasterizerUtils() {}
RasterizerUtils::~RasterizerUtils() {}

// --- Implementierung der Hauptfunktion ---
Dictionary RasterizerUtils::rasterize_tile_data(const Variant &mvt_tile_variant, const Dictionary &config) {
    Object *mvt_tile_obj = mvt_tile_variant;
    if (!mvt_tile_obj) {
        UtilityFunctions::push_warning("RasterizerUtils: MVT-Tile-Objekt ist null.");
        return Dictionary();
    }

    // --- Konfiguration auslesen ---
    const double sub_chunk_resolution = config.get("sub_chunk_resolution", 128.0);
    const int64_t sub_chunks_per_axis = config.get("sub_chunks_per_axis", 4);
    const Dictionary type_map = config.get("type_map", Dictionary());
    const Array render_order = config.get("render_order", Array());

    // --- Sub-Chunk-Container vorbereiten ---
    Dictionary prepared_sub_chunks;
    for (int64_t y = 0; y < sub_chunks_per_axis; ++y) {
        for (int64_t x = 0; x < sub_chunks_per_axis; ++x) {
            Vector2i coord(x, y);
            Ref<Image> logic_map = Image::create_empty(sub_chunk_resolution, sub_chunk_resolution, false, Image::FORMAT_R8);
            logic_map->fill(Color(0, 0, 0, 1));
            
            PackedByteArray vegetation_map;
            vegetation_map.resize(sub_chunk_resolution * sub_chunk_resolution);
            vegetation_map.fill(0); // Füllen mit Typ 0 (nichts)

            Dictionary chunk_data;
            chunk_data["logic_map"] = logic_map;
            chunk_data["is_dirty"] = true; // Damit dieser Chunk einfach mit Grass gefüllt wird, auch wenn keine OSM-Daten vorhanden sind
            chunk_data["vegetation_map"] = vegetation_map;
            prepared_sub_chunks[coord] = chunk_data;
        }
    }

    // --- Features gruppieren ---
    Dictionary all_features_by_type;
    Array layers = mvt_tile_obj->call("layers");
    if (layers.is_empty()) return Dictionary(); // Sicherheitsprüfung

    for (int i = 0; i < layers.size(); ++i) {
        Object *layer = layers[i];
        Array features = layer->call("features");
        for (int j = 0; j < features.size(); ++j) {
            Object *feature = features[j];
            Dictionary tags = feature->call("tags", layer);
            String type_tag = tags.get("type", "");
            if (type_map.has(type_tag)) {
                if (!all_features_by_type.has(type_tag)) {
                    all_features_by_type[type_tag] = Array();
                }
                Array feature_list = all_features_by_type[type_tag];
                feature_list.append(feature);
                all_features_by_type[type_tag] = feature_list;
            }
        }
    }

    // --- Rasterisierung ---
    Object* first_layer = layers[0];
    const double tile_extent = first_layer->call("extent");
    const double total_pixel_dim = sub_chunk_resolution * sub_chunks_per_axis;
	const double scale_vec_to_pixel = total_pixel_dim / tile_extent;
	const double scale_pixel_to_vec = tile_extent / total_pixel_dim;

    for (int i = 0; i < render_order.size(); ++i) {
        String type_name = render_order[i];
        if (!all_features_by_type.has(type_name)) continue;

        const int64_t type_id = type_map.get(type_name, 0);
        const Color type_color = Color(type_id / 255.0, 0, 0, 1);
        Array features_of_type = all_features_by_type[type_name];

        for (int j = 0; j < features_of_type.size(); ++j) {
            Object *feature = features_of_type[j];
            Array geometry_commands = feature->call("geometry");

            // Geometrie dekodieren
            Array all_rings;
            PackedVector2Array current_ring;
            Vector2 cursor(0, 0);
            for (int k = 0; k < geometry_commands.size(); ++k) {
                Array cmd_seq = geometry_commands[k];
                int64_t cmd_id = cmd_seq[0];
                if (cmd_id == 1) { // MoveTo
                    cursor += Vector2(cmd_seq[1], cmd_seq[2]);
                    current_ring.push_back(cursor);
                } else if (cmd_id == 2) { // LineTo
                    for (int l = 1; l < cmd_seq.size(); l += 2) {
                        cursor += Vector2(cmd_seq[l], cmd_seq[l + 1]);
                        current_ring.push_back(cursor);
                    }
                } else if (cmd_id == 7) { // ClosePath
                    if (!current_ring.is_empty()) {
                        all_rings.push_back(current_ring);
                        current_ring = PackedVector2Array();
                    }
                }
            }

            // Ringe klassifizieren
            Array outer_rings, inner_rings;
            for (int k = 0; k < all_rings.size(); ++k) {
                PackedVector2Array ring = all_rings[k];
                if (Geometry2D::get_singleton()->is_polygon_clockwise(ring)) {
                    inner_rings.push_back(ring);
                } else {
                    outer_rings.push_back(ring);
                }
            }
            if (outer_rings.is_empty()) continue;

            // Rasterisierung pro Aussenring
            for (int k = 0; k < outer_rings.size(); ++k) {
                PackedVector2Array poly = outer_rings[k];
                Rect2 bounds = get_polygon_bounds(poly);

                Rect2 global_pixel_bounds = Rect2(
                    bounds.get_position() * scale_vec_to_pixel,
                    bounds.get_size() * scale_vec_to_pixel
                );

                Vector2i start_chunk = (global_pixel_bounds.get_position() / sub_chunk_resolution).floor();
                Vector2i end_chunk = ((global_pixel_bounds.get_position() + global_pixel_bounds.get_size()) / sub_chunk_resolution).floor();

                for (int64_t chunk_y = start_chunk.y; chunk_y <= end_chunk.y; ++chunk_y) {
                    for (int64_t chunk_x = start_chunk.x; chunk_x <= end_chunk.x; ++chunk_x) {
                        Vector2i sub_chunk_coord(chunk_x, chunk_y);
                        if (!prepared_sub_chunks.has(sub_chunk_coord)) continue;

                        Dictionary chunk_data = prepared_sub_chunks[sub_chunk_coord];
                        Ref<Image> current_logic_map = chunk_data["logic_map"];
                        PackedByteArray veg_map = chunk_data["vegetation_map"];

                        for (int64_t pixel_y = 0; pixel_y < sub_chunk_resolution; ++pixel_y) {
                            for (int64_t pixel_x = 0; pixel_x < sub_chunk_resolution; ++pixel_x) {
                                Vector2 global_pixel_center(
                                    chunk_x * sub_chunk_resolution + pixel_x + 0.5,
                                    chunk_y * sub_chunk_resolution + pixel_y + 0.5
                                );

                                if (!global_pixel_bounds.has_point(global_pixel_center)) continue;

                                Vector2 point_in_poly_space = global_pixel_center * scale_pixel_to_vec;
                                
                                if (is_point_in_polygon(point_in_poly_space, poly)) {
                                    bool is_in_hole = false;
                                    for (int l = 0; l < inner_rings.size(); ++l) {
                                        if (is_point_in_polygon(point_in_poly_space, inner_rings[l])) {
                                            is_in_hole = true;
                                            break;
                                        }
                                    }
                                    if (!is_in_hole) {
                                        chunk_data["is_dirty"] = true;
                                        current_logic_map->set_pixel(pixel_x, pixel_y, type_color);

                                        //PackedByteArray veg_map = chunk_data["vegetation_map"];
                                        veg_map.set(pixel_y * sub_chunk_resolution + pixel_x, type_id);
                                    }
                                }
                            }
                        }
                        chunk_data["vegetation_map"] = veg_map;
                        prepared_sub_chunks[sub_chunk_coord] = chunk_data;
                    }
                }
            }
        }
    }
    
    Dictionary final_sub_chunks;
    Array chunk_coords = prepared_sub_chunks.keys();

    for (int i = 0; i < chunk_coords.size(); ++i) {
        Vector2i coord = chunk_coords[i];
        Dictionary original_chunk_data = prepared_sub_chunks[coord];

        PackedByteArray veg_map = original_chunk_data["vegetation_map"];
        Dictionary positions_by_type;

        for (int64_t y = 0; y < sub_chunk_resolution; ++y) {
            for (int64_t x = 0; x < sub_chunk_resolution; ++x) {
                uint8_t type_id = veg_map[y * sub_chunk_resolution + x];
                if (type_id > 0) { // Typ 0 ignorieren
                    if (!positions_by_type.has(type_id)) {
                        positions_by_type[type_id] = PackedVector3Array();
                    }
                    PackedVector3Array pos_array = positions_by_type[type_id];
                    pos_array.push_back(Vector3(x, 0, y));
                    positions_by_type[type_id] = pos_array;
                }
            }
        }

        //Dictionary final_chunk_data;
        //final_chunk_data["logic_map"] = original_chunk_data["logic_map"];

        // Erstelle ein neues Dictionary für die fertigen Buffer
        Dictionary vegetation_buffers;
        Array type_ids = positions_by_type.keys();

        for (int j = 0; j < type_ids.size(); ++j) {
            int64_t type_id = type_ids[j];
            PackedVector3Array positions = positions_by_type[type_id];
            int64_t instance_count = positions.size();
            if (instance_count == 0) continue;

            // Erstelle den finalen Buffer für diesen Typ
            // Pro Instanz: 12 floats für Transform3D + 4 für Custom Data = 16 floats
            const int64_t STRIDE = 16;
            PackedFloat32Array data_buffer;
            data_buffer.resize(instance_count * STRIDE);

            for (int k = 0; k < instance_count; ++k) {
                const Vector3 &pos = positions[k];
                Basis basis; // = Basis() oder Basis::IDENTITY
                int64_t buffer_start_index = k * STRIDE;
                
                // Schreibe die Transform-Daten im korrekten Column-Major-Layout
                data_buffer.set(buffer_start_index + 0, basis.get_column(0).x); // basis.x.x
                data_buffer.set(buffer_start_index + 1, basis.get_column(1).x); // basis.y.x
                data_buffer.set(buffer_start_index + 2, basis.get_column(2).x); // basis.z.x
                data_buffer.set(buffer_start_index + 3, pos.x);

                data_buffer.set(buffer_start_index + 4, basis.get_column(0).y); // basis.x.y
                data_buffer.set(buffer_start_index + 5, basis.get_column(1).y); // basis.y.y
                data_buffer.set(buffer_start_index + 6, basis.get_column(2).y); // basis.z.y
                data_buffer.set(buffer_start_index + 7, pos.y);

                data_buffer.set(buffer_start_index + 8, basis.get_column(0).z); // basis.x.z
                data_buffer.set(buffer_start_index + 9, basis.get_column(1).z); // basis.y.z
                data_buffer.set(buffer_start_index + 10, basis.get_column(2).z); // basis.z.z
                data_buffer.set(buffer_start_index + 11, pos.z);

                // Schreibe die Custom-Daten
                data_buffer.set(buffer_start_index + 12, rand() % 16); // r
                data_buffer.set(buffer_start_index + 13, 0.0);         // g
                data_buffer.set(buffer_start_index + 14, 0.0);         // b
                data_buffer.set(buffer_start_index + 15, 1.0);         // a
            }
            // Speichere den fertigen Buffer im Dictionary
            vegetation_buffers[type_id] = data_buffer;
        }
        Dictionary final_chunk_data;
        final_chunk_data["logic_map"] = original_chunk_data["logic_map"];
        final_chunk_data["vegetation_buffers"] = vegetation_buffers;
        final_sub_chunks[coord] = final_chunk_data;
    }
    
    // Gib die neue, finale Datenstruktur zurück
    Dictionary result;
    result["sub_chunks"] = final_sub_chunks;
    result["type_map"] = type_map;
    return result;
}

// --- Hilfsfunktionen ---
bool RasterizerUtils::is_point_in_polygon(const Vector2 &point, const PackedVector2Array &polygon) {
    // Deine robuste Implementierung
    int n = polygon.size();
    if (n < 3) return false;
    bool inside = false;
    for (int i = 0, j = n - 1; i < n; j = i++) {
        const Vector2 &pi = polygon[i];
        const Vector2 &pj = polygon[j];
        if (((pi.y > point.y) != (pj.y > point.y)) &&
            (point.x < (pj.x - pi.x) * (point.y - pi.y) / (pj.y - pi.y) + pi.x)) {
            inside = !inside;
        }
    }
    return inside;
}

Rect2 RasterizerUtils::get_polygon_bounds(const PackedVector2Array &polygon) {
    if (polygon.is_empty()) return Rect2();
    Vector2 min_p = polygon[0];
    Vector2 max_p = polygon[0];
    for (int i = 1; i < polygon.size(); ++i) {
        min_p.x = MIN(min_p.x, polygon[i].x);
        min_p.y = MIN(min_p.y, polygon[i].y);
        max_p.x = MAX(max_p.x, polygon[i].x);
        max_p.y = MAX(max_p.y, polygon[i].y);
    }
    return Rect2(min_p, max_p - min_p);
}